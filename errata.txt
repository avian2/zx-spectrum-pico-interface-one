v1.0
====

Transistor Q1 is rotated. Needs turning 90deg anticlockwise.
- Done on board #2

"ROM Acc 3V3" is on the silkscreen, test point was removed.
Same for "GND" just above U4.
- Done on board #2

The direction for the data bus level shifter needs to be
ROM_READ_INV, not /RD.
 - Cut ZXRD track on back of board #2
 - Picked up ROM_READ_INV from OR output (pin 9) and
   connected to DIR (pin 1) on level shifter U4
- Done on board #2
 
Move the GND via from pin 19 on U4, it's under the chip and
I can't get to it. This is /OE.
- Done on board #2

Remove level shifter U2
 - Bridged across gap on board #2
 - Removed on board #2

Remove level shifter U3
 - Bridged across gap on board #2
 - Removed on board #2

All the above were fixed (by hand) in v1.1


v1.1
====

Disconnect the 3V3s for all the Picos. I've got the outputs
of 3 regulators tied together. Separate into 3 supplies.
- Done on v1.2 of the board
- Cut 3V3 track to Pico2 on current board
: Need to cut 3v3 track to pico3 on current board


Change the dbus level shifter direction control from hardware to
software. Wire GPIO27 of Pico2 as an input for the ROM_READ_INV
signal, and GPIO28 as an output to the data bus level shifter's DIR
pin. This will allow the data bus to reverse direction on
memory reads, and also on IO request reads.
- Done on board #2,
- Done on v1.2 of the board


Remove the level shifter U202 which does IORQ, RD and WR.
These signals are permanently ZX->Pico so don't need shifting.
- Bridged on board #1
- Done on v1.2 of the board


I need to connect the /WAIT signal on the edge connector to GPIO18
on the IO Pico.
- Done on board #2
- Done on v1.2 of the board



v1.2
====

Make sure the GPIOs which share the ADC are not used for 5V. IO Pico
has ROM_READ_INV going into GPIO27. I need another level shifter.
I'm out of GPIOs.
- Level shifter has been added on v1.2 schematic
: I won't do it on board #1, adding the level shifter will be too
   difficult.
Make IO PIco GPIO27 an output (it's an ADC GPIO)
- Moved ROM_READ_INV to GPIO15 and ZXWAIT to GPIO27. That makes
  the signal on GPIO27 an output
- Done on board #1 and schematic
Set up the PSRAM connection on SPI0. That's GPIOs 16 to 19.
- Done on board #1 and schematic


Untangle the bus pins on all the Picos. Make databus D0 to D7
in sequence, then address lines. I thought simplifying the layout
process would make things easier, but actually, keeping the
software simple and fast has more benefit.
- Done on schematic, both Pico1 and Pico2
: Won't be doing this on board #1, too distruptive


Have Pico1 tell Pico2 that one of its ports (0xE7 or 0xEF) is on the
address bus. Then Pico2 can do away with 7 address lines.
- Done on board #1
- Signal from Pico1 GPIO27 to Pico2 GPIO13 done on board #1
- Keep A3 in place on Pico2


I need a signal from Pico2 to Pico1. Pico1 can't release the Z80
until Pico2 is ready to go. Pico2 changes the level shifter
direction, so Pico1 can't be the ROM until Pico2 is ready to go.
: Not required. If Pico1 boots slower than Pico2, then
   Pico2 will be running by the time Pico1 releases the Z80.
   I can just put a delay in the Pico1 code. Bit yuk, but I don't
   have the GPIO spare on Pico1.
:: Skip this for now


Add another couple of LEDs to the IO pico so I can see at a glance
if it's responding to IOs. Low priority, but if I have a couple
of GPIOs left this will be handy. Make sure the tracks are easy
to cut so i can reuse the GPIOs if I need to.
: Needs doing
:: No GPIO available, but I could connect an LED to the SPI
   slave enable signal? Check with AM whether that would 
   cause a problem



No pop the level shifter, I can probably just put a series resistor
on that signal line.


Test points required, bring them out to plated holes:
Test pin on Pico1, use pin 27, needed to trigger scope on particular
                   instruction, like INIR
Test pin on Pico2, use pin 27 here too, although there are more options
Test pin on Pico3, might as well use pin27 here too
ROM_READ_INV so I can see when Pico1 is telling Pico2 to change DIR
IORQ, RD and WR, make sure they're still available, they're useful
DIR_CHANGE from Pico2. I need to be able to see when Pico2 is changing the dbus direction.
: All need doing


v1.3 Final is for fabrication as board #2


v1.3 This version was made into board#2
====

Stagger the rows of data bus resistors. Offset each from the ones either side of
it so I can get the larger tweezers in. Or space them out a bit more.
: Needs doing


First attempt NOPOPed the extra level shifter and added a series 100R resistor
into the ROM_READ signal. Need to confirm this worked. Its function is to protect
the Pico's ADC GPIO which I'm putting 5V into. I can't really tell if it works
unless and until the Pico fails, but I can at least confirm 100R is correct for
timing.
: It didn't work, the signal from the 3V3 side of the resistor was OK, but the
  level was wrong. It went from 2.5V to about 1.5V. I didn't investigate, I
  just took the R100 off and added the level shifter.
:: Remove the resistor footprint and NOPOP silkscreen
: Needs doing


PSRAM footprint is missing the pin-1 dot on the silkscreen.
: Needs doing


OLED CLK and SDA signals are transposed. I've labelled Pico3 GPIO4 as CLK and
GPIO5 and SDA. Check the A4 pin out diagram: GPIO4 is SDA and GPIO5 is CLK.
This is a hardware I2C bus so I can't switch them in software.
: Needs doing


OLED screen is currently mounted upside and out the back. Work out where the
screen is going to be mounted and set the header correctly.
: Needs doing


Rotary encoder connection is reversed on the board, it needs to stick out the
back for the pins to be connected up correctly. I think it needs flipping over
to have the encorder out the front.
: Needs doing
:: I need to decide on the final layout before changing this


Rotary encoder pins are in sequence SW, DT, CLK, the example code I had ready
is CLK, DT, SW.
: Fixed in code
:: I need to decide whether to change this, it's probably OK as it is


SPI is not suitable for the Pico to Pico comms. Switched to UART. Connected
UART0 (GPIOs 0 to 3) on UI Pico to UART0 (GPIOs 12 to 15) on IO Pico.
: Fixed on board (soldered wires)
: Fixed in code
: Fixed on schematic
:: Needs fixing on PCB
---
: UARTs were too slow, I've switched again to the TP PIO link
:: This freed up the CTS/RTS pair so I have 2 GPIOs free again
:: Schematic and board updated, code working


SD Card reader card detect pin needs connecting up.
: Done on board, I used GPIO28 as input
: Fixed on schematic
:: Needs fixing on PCB


LED output. 8 LEDs for 8 microdrives isn't practical, I don't have the GPIOs and
the wiring is going to get very complicated. So 2 LEDs: one green to show any
microdrive is inserted, and one red to show any microdrive is motor on. For the
motor on LED, connect IO GPIO11 a output to a red LED via suitable resistor. Also
connect that signal to UI Pico GPIO27 as input, allowing UI Pico to know when any
motor is on. This is assumed to be useful for the GUI, but might not be
required.
For cartridge-inserted, connect UI GPIO11 as output to the green LED via series
resistor according to LED chosen.
Code can then set green LED on whenever a cartridge is inserted. Red LED can be lit
by IO Pico when a motor is on, and the UI Pico will see that signal so can update
the GUI if deemed required.
: Schematic updated, nothing tested
:: Confirm R value and footprint for suitable LEDs
: All needs doing after test on breadboard
** Undecided. A 74HS595 is serial in, 8-output, I have the GPIOs for that.
** Still undecided. I do now have 8 GPIOs free, I could do it the easy way


3-way RUN switch. I'm now having to power cycle the whole machine in order to
reset the UI Pico. A push to make switch which grounds all the RUN pins would
be very handy now.


Buzzer required
: Or not. It'll sound crap.
: I could use a motor, which will at least sound a bit more realistic

Input switches. The GUI is too messy with just the rotary encoder. I need a couple
of switches as extra inputs, maybe like "Action" and "Cancel".
: Schematic updated
: Tested and working on breadboard. I used UI GPIOs 26 and 22.


Case. 3D printed case required. I'm thinking of a tray to sit the lie-flat PCB in,
edge connectors front and back. It'll need screw point to hold the board, so the
board needs screw holes at the corners.


Daughterboard. The screen, rotary and 2 input switches need to be on a separate
daughterboard. This will be screw-mounted on mountpoints on the 3D printed case
and connected to the main PCB via a ribbon cable. I need

3V3
GND
OLED CLK
OLED DAT
Rotary DT
Rotary CLK
Rotary Switch
Action switch signal
Cancel switch signal

which is 9 signals. Short length of ribbon cable with crimped connectors should do
the job.